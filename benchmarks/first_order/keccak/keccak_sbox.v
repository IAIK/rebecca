
// Generated by Cadence Encounter(R) RTL Compiler RC14.27 - v14.20-s064_1

// Verification Directory fv/keccak_sbox 

module bmux(ctl, in_0, in_1, z);
  input ctl;
  input [9:0] in_0, in_1;
  output [9:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[9]), .data1 (in_1[9]), .z
       (z[9]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[8]), .data1 (in_1[8]), .z
       (z[8]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[7]), .data1 (in_1[7]), .z
       (z[7]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[6]), .data1 (in_1[6]), .z
       (z[6]));
  CDN_bmux2 g5(.sel0 (ctl), .data0 (in_0[5]), .data1 (in_1[5]), .z
       (z[5]));
  CDN_bmux2 g6(.sel0 (ctl), .data0 (in_0[4]), .data1 (in_1[4]), .z
       (z[4]));
  CDN_bmux2 g7(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g8(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g9(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g10(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module keccak_sbox(ClkxCI, RstxRBI, EnablexSI, IotaRCxDI, InputxDI,
     ZxDI, OutputxDO);
  input ClkxCI, RstxRBI, EnablexSI, IotaRCxDI;
  input [9:0] InputxDI;
  input [4:0] ZxDI;
  output [9:0] OutputxDO;
  wire [9:0] FFxDN;
  wire [9:0] FFxDP;
  bmux mux_FFxDP_114_10(.ctl (n_21), .in_0 (10'b0000000000), .in_1
       (10'b0000000000), .z ());
  not g2 (n_34, InputxDI[1]);
  and g3 (n_37, n_34, InputxDI[2]);
  xor g4 (\SBOX.result[0] , InputxDI[0], n_37);
  and g5 (n_38, InputxDI[1], InputxDI[7]);
  xor g6 (FFxDN[0], n_38, ZxDI[0]);
  xor g7 (OutputxDO[0], \SBOX.result[0] , FFxDP[0]);
  and g8 (n_41, InputxDI[6], InputxDI[2]);
  xor g9 (FFxDN[5], n_41, ZxDI[0]);
  xor g11 (n_45, FFxDP[5], InputxDI[5]);
  not g12 (n_44, InputxDI[6]);
  and g13 (n_46, n_44, InputxDI[7]);
  xor g14 (OutputxDO[5], n_45, n_46);
  not g16 (n_47, InputxDI[2]);
  and g17 (n_50, n_47, InputxDI[3]);
  xor g18 (\SBOX.result[0]_54 , InputxDI[1], n_50);
  and g19 (n_52, InputxDI[2], InputxDI[8]);
  xor g20 (FFxDN[1], n_52, ZxDI[1]);
  xor g21 (OutputxDO[1], \SBOX.result[0]_54 , FFxDP[1]);
  and g22 (n_55, InputxDI[7], InputxDI[3]);
  xor g23 (FFxDN[6], n_55, ZxDI[1]);
  xor g25 (n_58, FFxDP[6], InputxDI[6]);
  not g26 (n_57, InputxDI[7]);
  and g27 (n_59, n_57, InputxDI[8]);
  xor g28 (OutputxDO[6], n_58, n_59);
  not g30 (n_60, InputxDI[3]);
  and g31 (n_63, n_60, InputxDI[4]);
  xor g32 (\SBOX.result[0]_67 , InputxDI[2], n_63);
  and g33 (n_65, InputxDI[3], InputxDI[9]);
  xor g34 (FFxDN[2], n_65, ZxDI[2]);
  xor g35 (OutputxDO[2], \SBOX.result[0]_67 , FFxDP[2]);
  and g36 (n_68, InputxDI[8], InputxDI[4]);
  xor g37 (FFxDN[7], n_68, ZxDI[2]);
  xor g39 (n_71, FFxDP[7], InputxDI[7]);
  not g40 (n_70, InputxDI[8]);
  and g41 (n_72, n_70, InputxDI[9]);
  xor g42 (OutputxDO[7], n_71, n_72);
  not g44 (n_73, InputxDI[4]);
  and g45 (n_75, n_73, InputxDI[0]);
  xor g46 (\SBOX.result[0]_78 , InputxDI[3], n_75);
  and g47 (n_76, InputxDI[4], InputxDI[5]);
  xor g48 (FFxDN[3], n_76, ZxDI[3]);
  xor g49 (OutputxDO[3], \SBOX.result[0]_78 , FFxDP[3]);
  and g50 (n_79, InputxDI[9], InputxDI[0]);
  xor g51 (FFxDN[8], n_79, ZxDI[3]);
  xor g53 (n_82, FFxDP[8], InputxDI[8]);
  not g54 (n_81, InputxDI[9]);
  and g55 (n_83, n_81, InputxDI[5]);
  xor g56 (OutputxDO[8], n_82, n_83);
  not g58 (n_84, InputxDI[0]);
  and g59 (n_86, n_84, InputxDI[1]);
  xor g60 (\SBOX.result[0]_89 , InputxDI[4], n_86);
  and g61 (n_87, InputxDI[0], InputxDI[6]);
  xor g62 (FFxDN[4], n_87, ZxDI[4]);
  xor g63 (OutputxDO[4], \SBOX.result[0]_89 , FFxDP[4]);
  and g64 (n_90, InputxDI[5], InputxDI[1]);
  xor g65 (FFxDN[9], n_90, ZxDI[4]);
  xor g67 (n_93, FFxDP[9], InputxDI[9]);
  not g68 (n_92, InputxDI[5]);
  and g69 (n_94, n_92, InputxDI[6]);
  xor g70 (OutputxDO[9], n_93, n_94);
  not g71 (n_21, RstxRBI);
  CDN_flop \FFxDP_reg[0] (.clk (ClkxCI), .d (FFxDN[0]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[0]));
  CDN_flop \FFxDP_reg[1] (.clk (ClkxCI), .d (FFxDN[1]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[1]));
  CDN_flop \FFxDP_reg[2] (.clk (ClkxCI), .d (FFxDN[2]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[2]));
  CDN_flop \FFxDP_reg[3] (.clk (ClkxCI), .d (FFxDN[3]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[3]));
  CDN_flop \FFxDP_reg[4] (.clk (ClkxCI), .d (FFxDN[4]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[4]));
  CDN_flop \FFxDP_reg[5] (.clk (ClkxCI), .d (FFxDN[5]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[5]));
  CDN_flop \FFxDP_reg[6] (.clk (ClkxCI), .d (FFxDN[6]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[6]));
  CDN_flop \FFxDP_reg[7] (.clk (ClkxCI), .d (FFxDN[7]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[7]));
  CDN_flop \FFxDP_reg[8] (.clk (ClkxCI), .d (FFxDN[8]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[8]));
  CDN_flop \FFxDP_reg[9] (.clk (ClkxCI), .d (FFxDN[9]), .sena
       (EnablexSI), .aclr (n_21), .apre (1'b0), .srl (1'b0), .srd
       (1'b0), .q (FFxDP[9]));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge aclr) 
      if (aclr) 
        qi = 0;
      //else if (apre) 
          //qi = 1;
        //else if (srl) 
            //qi = srd;
          else begin
            //if (sena) 
              qi = d;
          end
  //initial 
    //qi = 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
