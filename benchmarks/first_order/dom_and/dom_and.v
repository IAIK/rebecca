
// Generated by Cadence Encounter(R) RTL Compiler RC14.27 - v14.20-s064_1

// Verification Directory fv/dom_and 

module bmux(ctl, in_0, in_1, z);
  input ctl;
  input [3:0] in_0, in_1;
  output [3:0] z;
  CDN_bmux2 g1(.sel0 (ctl), .data0 (in_0[3]), .data1 (in_1[3]), .z
       (z[3]));
  CDN_bmux2 g2(.sel0 (ctl), .data0 (in_0[2]), .data1 (in_1[2]), .z
       (z[2]));
  CDN_bmux2 g3(.sel0 (ctl), .data0 (in_0[1]), .data1 (in_1[1]), .z
       (z[1]));
  CDN_bmux2 g4(.sel0 (ctl), .data0 (in_0[0]), .data1 (in_1[0]), .z
       (z[0]));
endmodule

module dom_and(ClkxCI, RstxBI, XxDI, YxDI, ZxDI, QxDO);
  input ClkxCI, RstxBI;
  input [1:0] XxDI, YxDI;
  input [0:0] ZxDI;
  output [1:0] QxDO;
  wire [3:0] FFxDP;
  bmux mux_FFxDP_78_15(.ctl (n_8), .in_0 (4'b0000), .in_1 (4'b0000), .z
       ());
  and g1 (\Xi_mul_Yj[3] , XxDI[1], YxDI[1]);
  and g2 (Xi_mul_Yj_37, XxDI[1], YxDI[0]);
  and g3 (Xi_mul_Yj, XxDI[0], YxDI[1]);
  and g4 (\Xi_mul_Yj[0] , XxDI[0], YxDI[0]);
  xor g7 (n_11, Xi_mul_Yj, ZxDI);
  xor g8 (QxDO[0], \Xi_mul_Yj[0] , FFxDP[1]);
  xor g9 (n_13, Xi_mul_Yj_37, ZxDI);
  xor g11 (QxDO[1], FFxDP[2], \Xi_mul_Yj[3] );
  CDN_flop \FFxDP_reg[0] (.clk (ClkxCI), .d (\Xi_mul_Yj[0] ), .sena
       (1'b1), .aclr (n_8), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       ());
  CDN_flop \FFxDP_reg[1] (.clk (ClkxCI), .d (n_11), .sena (1'b1), .aclr
       (n_8), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (FFxDP[1]));
  CDN_flop \FFxDP_reg[2] (.clk (ClkxCI), .d (n_13), .sena (1'b1), .aclr
       (n_8), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (FFxDP[2]));
  CDN_flop \FFxDP_reg[3] (.clk (ClkxCI), .d (\Xi_mul_Yj[3] ), .sena
       (1'b1), .aclr (n_8), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       ());
  not g14 (n_8, RstxBI);
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
`ifdef RC_CDN_GENERIC_GATE
`else
`ifdef ONE_HOT_MUX
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  reg  z;
  always 
    @(sel0 or data0 or data1) 
      case ({sel0})
       1'b0: z = data0;
       1'b1: z = data1;
      endcase
endmodule
`else
module CDN_bmux2(sel0, data0, data1, z);
  input sel0, data0, data1;
  output z;
  not i_0 (inv_sel0, sel0);
  and a_0 (w_0, inv_sel0, data0);
  and a_1 (w_1, sel0, data1);
  or org (z, w_0, w_1);
endmodule
`endif // ONE_HOT_MUX
`endif
